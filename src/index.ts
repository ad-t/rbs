import dotenv from "dotenv";
import express from "express";
import dayjs from "dayjs";
import utc from "dayjs/plugin/utc";
import timezone from "dayjs/plugin/timezone";
import swaggerJsdoc from "swagger-jsdoc";
import swaggerUi from "swagger-ui-express";
import bodyParser = require("body-parser");
import cron = require("node-cron");

import "reflect-metadata";
import {
  ConnectionOptions,
  createConnection,
  getConnection,
  getRepository,
  LessThan
} from "typeorm";

import { Order } from "./entity/order";
import { Production } from "./entity/production";
import { Show } from "./entity/show";
import { Discount } from "./entity/discount";

// libraries
import { seedDB } from "./dev";
import { Payment } from "./entity/payment";
import { Ticket } from "./entity/ticket";
import { TicketType } from "./entity/ticket_type";
import { VenueSeat } from "./entity/venue_seat";
import Logger from "./logging";

import getMainRouter from "./main";
import getAdminRouter from "./admin";

// initialise config
dotenv.config();

dayjs.extend(utc);
dayjs.extend(timezone);
// TODO: change this if we ever change
dayjs.tz.setDefault("Australia/Sydney")

const app = express();
const API_PORT = process.env.SERVER_PORT;
const API_HOST = "http://localhost";
app.use(genericLoggingMiddleware);

const swaggerjsdocOptions: any = {
  apis: ["./dist/**/*.js"],
  swaggerDefinition: {
    info: {
      description: "API for the Revue Booking System site with autogenerated swagger docs",
      title: "Revue Booking System API",
      version: "1.0.0",
    },
  },
};

const specs = swaggerJsdoc(swaggerjsdocOptions);

const activeEntities = [
  Production,
  Show,
  Order,
  Payment,
  TicketType,
  Ticket,
  VenueSeat,
  Discount
];

const options: ConnectionOptions = {
  database: process.env.MYSQL_DATABASE,
  entities: activeEntities,
  host: "localhost",
  logging: false,
  migrations: [
    // "src/migration/**/*.ts"
  ],
  password: process.env.MYSQL_PASSWD,
  port: 3306,
  subscribers: [
    // "src/subscriber/**/*.ts"
  ],
  synchronize: true,
  type: "mysql",
  username: process.env.MYSQL_USER,
};

function genericLoggingMiddleware(req: express.Request, res: express.Response, next: express.NextFunction) {
  function afterResponse() {
    res.removeListener("finish", afterResponse);
    res.removeListener("close", afterResponse);
    Logger.Info(`${req.method} ${res.statusCode} - ${req.path}`);
  }

  res.on("finish", afterResponse);
  res.on("close", afterResponse);
  next();
}

// setup
async function bootstrap() {
  Logger.Info("Creating database connection...");
  await createConnection(options);
  if (process.env.NODE_ENV === "development") {
    Logger.Info("Development environment: to clear the tables, go to /reset");
  }
  if (process.env.NODE_ENV === "test") {
    Logger.Info("Test environment: will purge database");
    resetDB();
  }
}

async function resetDB() {
  Logger.Info("Purging the database tables...");
  // Can't use .clear() as TRUNCATE doesn't work with foreign key constraints.
  /*await Promise.all(
    activeEntities.map(async (entity) => await getRepository(entity).delete({}))
  );*/
  for (const entity of activeEntities) {
    await getRepository(entity).delete({});
  }
  Logger.Info("Seeding database...");
  await seedDB();
}

Logger.Init();
app.use(bodyParser.json());


if (process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test") {
  Logger.Info(`API documentation available at ${API_HOST}:${API_PORT}/docs`);
  app.use("/docs", swaggerUi.serve, swaggerUi.setup(specs));

  app.get("/reset", async function (_, res) {
    try {
      await resetDB();
      res.json({success: true});
    } catch (err) {
      Logger.Error(err.stack);
      res.status(500).json({error: "Internal server error"});
    }
  });

  let now = dayjs().tz();
  console.log(now.format());
}

app.listen(API_PORT, async () => {
  await bootstrap();
  Logger.Info(`Server started at ${API_HOST}:${API_PORT}`);
});

if (process.env.NODE_ENV !== "test") {
  // Remove unpaid orders if they've been left there.
  /*
  cron.schedule('* * * * *', async () => {
    try {
      const repo = getRepository(Order);
      Logger.Info("Purging unpaid orders...");
      const toDelete = await repo.find({
        // FIXME: apparently this doesn't work on sqlite but does on MySQL???
        // https://github.com/typeorm/typeorm/issues/2286
        updatedAt: LessThan(new Date(Date.now() - 20 * 60 * 1000)),
        paid: false
      });

      await repo.remove(toDelete);
      Logger.Info(`purge: ${toDelete.length} unpaid orders removed.`);
    } catch (e) {
      console.error(e);
    }
  });
  */
}

app.use('/admin', getAdminRouter());
app.use('/', getMainRouter());


